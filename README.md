# MeepleAI Monorepo

![CI](https://github.com/MeepleAI/meepleai-monorepo/actions/workflows/ci.yml/badge.svg)


Questo repository ospita gli stack principali di MeepleAI:

- **apps/web** ‚Äì front-end Next.js per l'interfaccia degli agenti Meeple.
- **apps/api** ‚Äì API .NET per ingesti PDF, Q&A e seed di demo.
- **infra/** ‚Äì definizioni Docker Compose e file di ambiente per avviare rapidamente i servizi di base (Postgres, Redis, Qdrant, n8n, API e web).

## Avvio rapido con Docker Compose

1. Copia i template `infra/env/*.env.dev.example` in file `infra/env/*.env.dev` non tracciati (lo script `scripts/dev-up.ps1` lo fa automaticamente al primo avvio) e personalizzali con i tuoi segreti locali. Tutti i valori forniti di default sono sicuri per lo sviluppo locale.
2. Avvia lo stack completo:
   ```bash
   cd infra
   docker compose up -d --build
   ```
3. Apri il front-end su [http://localhost:3000](http://localhost:3000) e le API su [http://localhost:8080](http://localhost:8080).

Ogni servizio espone un healthcheck nel `docker-compose.yml`, per cui `docker compose ps` mostra lo stato "healthy" quando l'avvio √® completo.

## Database

### Avvio di Postgres via Docker Compose

- Il servizio Postgres √® definito in `infra/docker-compose.yml` con credenziali di default `meeple / meeplepass` e database `meepleai`.\
  Puoi avviare solo il database (pi√π eventuali dipendenze) con:
  ```bash
  cd infra
  docker compose up -d postgres
  ```
- Il volume `pgdata` mantiene i dati tra i riavvii; lo script `infra/init/postgres-init.sql` √® montato come bootstrap e rimane vuoto perch√© lo schema √® gestito da EF Core.

### Migrazioni EF Core

- Assicurati di avere installato lo strumento CLI (`dotnet tool install --global dotnet-ef`) e di esportare le variabili d'ambiente presenti in `infra/env/api.env.dev.example` (copiandole in `infra/env/api.env.dev`) o in un tuo `.env` locale.
- Posizionati nel progetto API e applica le migrazioni con:
  ```bash
  cd apps/api/src/Api
  dotnet ef database update
  ```
  Se stai aggiungendo una nuova migrazione, usa `dotnet ef migrations add <NomeMigrazione>` specificando `--project` e `--startup-project` se lavori da una directory diversa.
- Le migrazioni generate sono versionate nella cartella `apps/api/src/Api/Migrations/`, cos√¨ da avere commit tracciabili insieme al codice applicativo.

### Modello dati condiviso

MeepleAI adotta ora un modello dati completamente condiviso: tutte le entit√† applicative risiedono nello stesso contesto e non richiedono pi√π identificatori di partizione.

- Tabelle come `users`, `games`, `rule_specs`, `agents`, `chats`, `chat_logs` e `audit_logs` sono indicizzate sulle chiavi naturali specifiche del dominio (ad esempio `user_id`, `game_id`, `rule_spec_id`).
- I servizi applicativi non valorizzano pi√π campi di isolamento nelle query o negli eventi; l'accesso ai dati √® governato esclusivamente da permessi applicativi e relazioni tra entit√†.
- Le migrazioni recenti hanno rimosso le vecchie dipendenze da ID di partizione e consolidato i vincoli `NOT NULL`/FK sulle chiavi di dominio effettive, mantenendo inalterata la coerenza del database.

### Seed demo e dati iniziali

- L'endpoint `POST /admin/seed` popola (o rigenera) una demo di regole di gioco tramite `RuleSpecService`, utile per validare rapidamente lo stack QA; lo script `scripts/seed-demo.ps1` lo invoca automaticamente contro le API locali.
- I dati demo vengono creati automaticamente per il contesto condiviso, con gioco di esempio `demo-chess`; non √® necessario configurare identificatori aggiuntivi lato web o API.
- Le chat continuano a referenziare `game_id` e `rule_spec_id`; quando si applicano nuove migrazioni verificare che le FK mantengano `ON DELETE CASCADE` o strategie equivalenti.

## Autenticazione e ruoli

- Le API espongono gli endpoint `POST /auth/register`, `POST /auth/login`, `POST /auth/logout` e `GET /auth/me`. La registrazione opera direttamente sul contesto globale e assegna un ruolo (`Admin`, `Editor`, `User`).
- Le sessioni sono persistite in tabella `user_sessions` con token casuali hashati; il token √® inviato al client tramite cookie `HttpOnly`.
- Gli endpoint protetti (`/agents/qa`, `/ingest/pdf`, `/admin/seed`) richiedono una sessione valida e rispettano i permessi: solo Admin pu√≤ eseguire il seed, Admin/Editor possono accedere a ingest, tutti i ruoli autenticati possono usare il QA per i giochi disponibili nel catalogo condiviso.

## Struttura

```
apps/
  web/          # Next.js app + Dockerfile + template .env.dev.example
  api/          # Progetto .NET (Api + test + Dockerfile)
infra/
  docker-compose.yml
  env/          # Template .env.dev.example e .env.ci.example per i servizi
  init/         # Script inizializzazione Postgres
meepleai_backlog/ # Backlog prodotto
scripts/, tools/, schemas/ ...
```

## Test locali

- Front-end: `cd apps/web && npm test`
- API: `cd apps/api && dotnet test` (richiede .NET 8 SDK installato in locale)

Per altre linee guida consulta `agents.md` e i README specifici nelle rispettive app.

## üìÑ PDF Import Wizard

Il wizard di import dei PDF (pagina `/upload`) guida editor e admin nell'intero flusso:

1. **Selezione gioco** ‚Äì scegli un gioco esistente e premi ‚ÄúConfirm selection‚Äù, oppure creane uno nuovo. L'upload resta disabilitato finch√© non c'√® una conferma.
2. **Upload PDF** ‚Äì seleziona un file `.pdf` e premi ‚ÄúUpload & Continue‚Äù. L'app invia il file a `/ingest/pdf` e salva l'`documentId` restituito.
3. **Parsing asincrono** ‚Äì la fase ‚ÄúParse‚Äù esegue polling automatico su `/pdfs/{documentId}/text` ogni pochi secondi, mostra la barra di avanzamento e rende visibili eventuali errori (`processingError`). Il pulsante di continuazione rimane disabilitato finch√© lo stato non diventa `completed`.
4. **Review automatica** ‚Äì non appena il backend segnala `processingStatus: completed`, il wizard carica la RuleSpec reale (`GET /games/{gameId}/rulespec`) e passa alla fase di review senza intervento manuale.
5. **Pubblicazione** ‚Äì dopo aver eventualmente modificato le regole estratte, premi ‚ÄúPublish RuleSpec‚Äù per inviare l'aggiornamento alle API.

Se l'elaborazione fallisce (`processingStatus: failed`), il wizard mostra l'errore restituito e invita a ripartire dall'upload.

## Contribuire

Accogliamo contributi dalla community! Prima di iniziare:

- **[CONTRIBUTING.md](CONTRIBUTING.md)** - Linee guida per pull request, coding standards, e testing
- **[SECURITY.md](SECURITY.md)** - Policy di sicurezza e come segnalare vulnerabilit√†
- **[agents.md](agents.md)** - Standard operativi per agenti di coding (Codex/Claude Code)

## Hook di sicurezza locali

1. Installa le dipendenze di sviluppo Python (richiede Python 3.9+):
   ```bash
   python -m pip install --user -r requirements-dev.txt
   ```
   > Su Windows puoi usare `py -3 -m pip install --user -r requirements-dev.txt`. Se ottieni l'errore `No module named pre_commit`, ripeti il comando per assicurarti che `pip` abbia installato il pacchetto.
2. Installa gli hook di pre-commit nel repository:
   ```bash
   pre-commit install
   ```
3. Esegui un controllo completo (opzionale ma consigliato prima del primo commit):
   ```bash
   pre-commit run --all-files
   ```

## Gestione secrets e rotazione

- I file `infra/env/*.env.dev` restano fuori dal versionamento (`.gitignore`) e sono pensati solo per lo sviluppo locale. Usa i template `*.env.dev.example` come base e mantieni le credenziali nel tuo password manager.
- Per la CI utilizza variabili sicure (GitHub Secrets/Environments) che popolano file `infra/env/*.env.ci` o variabili d'ambiente equivalenti. I template `*.env.ci.example` elencano i nomi richiesti senza fornire valori sensibili.
- **Rotazione OpenRouter API key:** genera una chiave dedicata per MeepleAI, ruotala almeno ogni 90 giorni o immediatamente in caso di sospetta fuga, aggiorna il secret GitHub `OPENROUTER_API_KEY` e invalida la chiave precedente dal pannello OpenRouter.
- **Rotazione GitHub PAT (per n8n o automazioni):** usa PAT con scope minimi, memorizzalo come secret GitHub (`GITHUB_TOKEN`/`N8N_GITHUB_PAT`), ruotalo ogni 90 giorni e revoca immediatamente i token inutilizzati.
- Configura gli hook di sicurezza come descritto nella sezione precedente: il gancio `detect-secrets` blocca la maggior parte dei leak accidentali; aggiorna il baseline con `detect-secrets scan > .secrets.baseline` solo dopo aver verificato che non siano presenti segreti reali.

## üó∫Ô∏è Roadmap

### ‚úÖ Completato

#### Infrastruttura & DevOps
- ‚úÖ Architettura microservizi con Docker Compose
- ‚úÖ CI/CD pipeline con GitHub Actions
- ‚úÖ Integration tests in CI con Qdrant gRPC
- ‚úÖ Pre-commit hooks per sicurezza (detect-secrets, secret scanning)
- ‚úÖ Gestione environment multi-ambiente (.env.dev, .env.ci)
- ‚úÖ Health checks per tutti i servizi

#### Backend (.NET 8)
- ‚úÖ API REST con minimal APIs
- ‚úÖ Modello dati condiviso senza partizioni dedicate
- ‚úÖ Autenticazione basata su sessioni con cookie HttpOnly
- ‚úÖ Autorizzazione role-based (Admin, Editor, User)
- ‚úÖ Integrazione PostgreSQL con EF Core migrations
- ‚úÖ Cache distribuita con Redis
- ‚úÖ RAG (Retrieval-Augmented Generation) con Qdrant
- ‚úÖ PDF extraction service (Docnet + tabelle)
- ‚úÖ Seed demo data per testing
- ‚úÖ Storico versioni, diff e ripristino delle RuleSpec disponibili via API `GET /rulespecs/{id}/versions` e interfaccia `/versions`

#### Frontend (Next.js)
- ‚úÖ Interfaccia web React/TypeScript
- ‚úÖ API client con gestione errori
- ‚úÖ Health check endpoints
- ‚úÖ Integrazione con backend API
- ‚úÖ Gestione upload PDF con wizard multi-step con tracking avanzato dei progressi, connesso agli endpoint backend `/ingest/pdf` e `/games/{id}/pdfs`
- ‚úÖ Polling automatico dello stato di parsing (`/pdfs/{documentId}/text`) con barra di avanzamento e avanzamento automatico alla review

#### Admin & Automazione
- ‚úÖ Dashboard amministrazione contenuti con log filtrabili, statistiche operative e gestione workflow n8n
- ‚úÖ n8n workflow engine setup
- ‚úÖ Webhook n8n per Q&A endpoint

#### Documentazione
- ‚úÖ CONTRIBUTING.md - linee guida per contributi
- ‚úÖ SECURITY.md - policy di sicurezza
- ‚úÖ CLAUDE.md - guida sviluppo per AI agents
- ‚úÖ agents.md - standard operativi coding agents

#### Testing & CI
- ‚úÖ PDF extraction in CI (libgdiplus, Docnet runtime Linux)
- ‚úÖ Integration tests con TestContainers (PostgreSQL + Qdrant)
- ‚úÖ Suite test automatizzata attiva (75 backend, 11 unit frontend, 5 E2E; totale 91) ‚Äî dettagli in `TEST-SUMMARY.md`
- ‚úÖ Coverage reporting automatico

### üöß In corso

- üöß Miglioramento error handling e logging

### üìã Pianificato (Q1-Q2 2025)

#### Core Features
- üìã **Ingestion Pipeline completo**
  - Upload multipli PDF
  - Processamento asincrono con coda
  - Estrazione avanzata tabelle e immagini
  - Chunking intelligente per RAG

- üìã **Chat multi-turno persistente**
  - Storico conversazioni per game/rule_spec
  - Context window management
  - Follow-up questions intelligenti

- üìã **Gestione avanzata rule specs**
  - Retention policy per vecchie versioni

#### UX & Frontend
- üìã UI/UX completo per chat interfaccia
- üìã Dashboard amministrazione contenuti
- üìã Gestione upload PDF con progress tracking
- üìã Visualizzazione source documents per risposte

#### Integrazioni
- üìã Supporto multiple LLM providers (oltre OpenRouter)
- üìã Webhook system per eventi (new chat, ingestion complete)
- üìã API pubblica per integrazioni terze parti

#### Performance & Scale
- üìã Caching avanzato strategie (per query e profilo utente)
- üìã Ottimizzazione vector search con filtri pre-compute
- üìã Monitoring e observability (OpenTelemetry)

### üîÆ Visione futura (2025+)

- üîÆ **Multi-modal support**: immagini, diagrammi, video tutorial giochi
- üîÆ **AI Game Master**: agente autonomo che simula partite
- üîÆ **Community features**: condivisione Q&A, knowledge base pubblica
- üîÆ **Mobile app**: client iOS/Android nativo
- üîÆ **Voice interface**: Q&A vocale durante le partite
- üîÆ **Gamification**: statistiche utilizzo, achievements, leaderboard
- üîÆ **Marketplace**: regole custom, espansioni community-driven
- üîÆ **Real-time multiplayer**: assistenza durante partite online

### Priorit√† di sviluppo

La roadmap segue queste priorit√†:
1. **Stabilit√†**: Fix CI/CD e test reliability (Q1 2025)
2. **Core functionality**: Ingestion completo e chat persistente (Q1-Q2 2025)
3. **User experience**: UI/UX migliorato (Q2 2025)
4. **Scale & Performance**: Ottimizzazioni e monitoring (Q2-Q3 2025)
5. **Innovation**: Features avanzate e multi-modal (Q4 2025+)

Per seguire i progressi in tempo reale, consulta la [Project Board](https://github.com/MeepleAI/meepleai-monorepo/projects) e le [Issues](https://github.com/MeepleAI/meepleai-monorepo/issues).
