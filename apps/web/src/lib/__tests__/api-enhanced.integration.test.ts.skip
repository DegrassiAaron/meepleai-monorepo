/**
 * Integration tests for enhanced API client
 */

// Mock fetch BEFORE any imports
const mockFetch = jest.fn();
global.fetch = mockFetch as any;

import { apiEnhanced } from '../api-enhanced';
import { ApiError, NetworkError } from '../errors';

describe('apiEnhanced integration tests', () => {
  beforeEach(() => {
    mockFetch.mockClear();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('successful requests', () => {
    it('should make successful GET request', async () => {
      const mockData = { id: '123', name: 'Test Game' };
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers({ 'X-Correlation-Id': 'corr-123' }),
        json: async () => mockData
      });

      const result = await apiEnhanced.get('/api/v1/games/123');

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledTimes(1);
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/v1/games/123'),
        expect.objectContaining({
          method: 'GET',
          credentials: 'include'
        })
      );
    });

    it('should make successful POST request', async () => {
      const requestBody = { name: 'New Game' };
      const mockData = { id: '456', name: 'New Game' };

      mockFetch.mockResolvedValue({
        ok: true,
        status: 201,
        headers: new Headers({ 'X-Correlation-Id': 'corr-456' }),
        json: async () => mockData
      });

      const result = await apiEnhanced.post('/api/v1/games', requestBody);

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/v1/games'),
        expect.objectContaining({
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(requestBody)
        })
      );
    });

    it('should make successful PUT request', async () => {
      const requestBody = { name: 'Updated Game' };
      const mockData = { id: '789', name: 'Updated Game' };

      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers(),
        json: async () => mockData
      });

      const result = await apiEnhanced.put('/api/v1/games/789', requestBody);

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/v1/games/789'),
        expect.objectContaining({
          method: 'PUT',
          body: JSON.stringify(requestBody)
        })
      );
    });

    it('should make successful DELETE request', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 204,
        headers: new Headers()
      });

      await apiEnhanced.delete('/api/v1/games/123');

      expect(mockFetch).toHaveBeenCalledWith(
        expect.stringContaining('/api/v1/games/123'),
        expect.objectContaining({
          method: 'DELETE'
        })
      );
    });
  });

  describe('error handling', () => {
    it('should return null for 401 on GET request', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 401,
        statusText: 'Unauthorized',
        headers: new Headers()
      });

      const result = await apiEnhanced.get('/api/v1/protected');

      expect(result).toBeNull();
    });

    it('should throw ApiError for 404', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        headers: new Headers({ 'X-Correlation-Id': 'corr-404' })
      });

      await expect(apiEnhanced.get('/api/v1/games/999')).rejects.toThrow(ApiError);

      try {
        await apiEnhanced.get('/api/v1/games/999');
      } catch (error) {
        expect(error).toBeInstanceOf(ApiError);
        expect((error as ApiError).statusCode).toBe(404);
        expect((error as ApiError).correlationId).toBe('corr-404');
      }
    });

    it('should throw ApiError for 500', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        headers: new Headers()
      });

      await expect(apiEnhanced.get('/api/v1/games')).rejects.toThrow(ApiError);
    });

    it('should throw NetworkError on connection failure', async () => {
      mockFetch.mockRejectedValue(new TypeError('Failed to fetch'));

      await expect(apiEnhanced.get('/api/v1/games')).rejects.toThrow(NetworkError);
    });
  });

  describe('retry logic', () => {
    it('should retry on 500 error and succeed', async () => {
      jest.useFakeTimers();
      const mockData = { id: '123', name: 'Test Game' };

      mockFetch
        .mockResolvedValueOnce({
          ok: false,
          status: 500,
          statusText: 'Internal Server Error',
          headers: new Headers()
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          headers: new Headers(),
          json: async () => mockData
        });

      const promise = apiEnhanced.get('/api/v1/games/123');

      // Run all pending timers to execute retry delay
      await jest.runAllTimersAsync();

      const result = await promise;

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    it('should retry on network error and succeed', async () => {
      jest.useFakeTimers();
      const mockData = { id: '123', name: 'Test Game' };

      mockFetch
        .mockRejectedValueOnce(new TypeError('Network error'))
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          headers: new Headers(),
          json: async () => mockData
        });

      const promise = apiEnhanced.get('/api/v1/games/123');

      await jest.runAllTimersAsync();

      const result = await promise;

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    it('should not retry 404 errors', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 404,
        statusText: 'Not Found',
        headers: new Headers()
      });

      await expect(apiEnhanced.get('/api/v1/games/999')).rejects.toThrow(ApiError);

      expect(mockFetch).toHaveBeenCalledTimes(1);
    });

    it('should use exponential backoff for retries', async () => {
      jest.useFakeTimers();
      mockFetch.mockResolvedValue({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        headers: new Headers()
      });

      const promise = apiEnhanced.get('/api/v1/games/123');

      await jest.runAllTimersAsync();

      await expect(promise).rejects.toThrow(ApiError);

      expect(mockFetch).toHaveBeenCalledTimes(3); // Default maxAttempts
    });

    it('should respect custom retry config', async () => {
      jest.useFakeTimers();
      const mockData = { id: '123', name: 'Test Game' };

      mockFetch
        .mockResolvedValueOnce({
          ok: false,
          status: 500,
          headers: new Headers()
        })
        .mockResolvedValueOnce({
          ok: true,
          status: 200,
          headers: new Headers(),
          json: async () => mockData
        });

      const promise = apiEnhanced.get('/api/v1/games/123', {
        retry: {
          maxAttempts: 2,
          initialDelayMs: 500,
          maxDelayMs: 5000,
          backoffMultiplier: 2
        }
      });

      await jest.runAllTimersAsync();

      const result = await promise;

      expect(result).toEqual(mockData);
      expect(mockFetch).toHaveBeenCalledTimes(2);
    });

    it('should skip retry when skipRetry is true', async () => {
      mockFetch.mockResolvedValue({
        ok: false,
        status: 500,
        headers: new Headers()
      });

      await expect(
        apiEnhanced.get('/api/v1/games/123', { skipRetry: true })
      ).rejects.toThrow(ApiError);

      expect(mockFetch).toHaveBeenCalledTimes(1);
    });
  });

  describe('timeout handling', () => {
    it('should timeout if request exceeds timeout', async () => {
      jest.useFakeTimers();
      mockFetch.mockImplementation(
        () =>
          new Promise((resolve) => {
            setTimeout(
              () =>
                resolve({
                  ok: true,
                  status: 200,
                  headers: new Headers(),
                  json: async () => ({ data: 'slow' })
                }),
              5000
            );
          })
      );

      const promise = apiEnhanced.get('/api/v1/slow', { timeout: 2000, skipRetry: true });

      // Advance only to timeout threshold
      await jest.advanceTimersByTimeAsync(2000);

      await expect(promise).rejects.toThrow();
    });
  });

  describe('correlation ID tracking', () => {
    it('should extract and track correlation ID from response', async () => {
      const mockData = { id: '123' };
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers({ 'X-Correlation-Id': 'test-corr-123' }),
        json: async () => mockData
      });

      const response = await apiEnhanced.getWithMetadata('/api/v1/games/123');

      expect(response.correlationId).toBe('test-corr-123');
      expect(response.data).toEqual(mockData);
      expect(response.statusCode).toBe(200);
    });

    it('should handle missing correlation ID', async () => {
      const mockData = { id: '123' };
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers(),
        json: async () => mockData
      });

      const response = await apiEnhanced.getWithMetadata('/api/v1/games/123');

      expect(response.correlationId).toBeUndefined();
    });
  });

  describe('different content types', () => {
    it('should handle JSON response', async () => {
      const mockData = { id: '123', name: 'Test' };
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers({ 'content-type': 'application/json' }),
        json: async () => mockData
      });

      const result = await apiEnhanced.get('/api/v1/games/123');

      expect(result).toEqual(mockData);
    });

    it('should handle 204 No Content response', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 204,
        headers: new Headers()
      });

      const result = await apiEnhanced.get('/api/v1/status');

      expect(result).toBeNull();
    });

    it('should handle text response', async () => {
      mockFetch.mockResolvedValue({
        ok: true,
        status: 200,
        headers: new Headers({ 'content-type': 'text/plain' }),
        text: async () => 'Plain text response'
      });

      const result = await apiEnhanced.get('/api/v1/text');

      expect(result).toBe('Plain text response');
    });
  });
});
