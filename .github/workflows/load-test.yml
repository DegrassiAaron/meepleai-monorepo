name: Load Testing

on:
  workflow_dispatch:
    inputs:
      scenario:
        description: 'Load test scenario'
        required: true
        default: 'users100'
        type: choice
        options:
          - users100
          - users500
          - users1000

# Optimization: Share environment variables across jobs
env:
  POSTGRES_USER: meeple
  POSTGRES_PASSWORD: meeplepass
  POSTGRES_DB: meepleai
  DOTNET_VERSION: '9.0.x'
  K6_VERSION: '0.53.0'

jobs:
  # Optimization 1: Shared setup job for common dependencies
  setup:
    name: Setup Dependencies
    runs-on: ubuntu-latest
    outputs:
      cache-hit-nuget: ${{ steps.cache-nuget.outputs.cache-hit }}
      cache-hit-k6: ${{ steps.cache-k6.outputs.cache-hit }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Optimization 2: Cache .NET NuGet packages
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet packages
        id: cache-nuget
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore .NET dependencies
        if: steps.cache-nuget.outputs.cache-hit != 'true'
        run: |
          cd apps/api
          dotnet restore

      # Optimization 3: Cache k6 installation
      - name: Cache k6
        id: cache-k6
        uses: actions/cache@v4
        with:
          path: /usr/bin/k6
          key: ${{ runner.os }}-k6-${{ env.K6_VERSION }}
          restore-keys: |
            ${{ runner.os }}-k6-

      - name: Install k6
        if: steps.cache-k6.outputs.cache-hit != 'true'
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg \
            --keyserver hkp://keyserver.ubuntu.com:80 \
            --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | \
            sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

  # Optimization 4: Shared infrastructure job
  infrastructure:
    name: Start Infrastructure
    runs-on: ubuntu-latest
    needs: setup

    # Optimization 5: Use service containers instead of docker-compose
    services:
      postgres:
        image: postgres:16.4-alpine3.20
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      redis:
        image: redis:7.4.1-alpine3.20
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      qdrant:
        image: qdrant/qdrant:v1.12.4
        ports:
          - 6333:6333
          - 6334:6334
        options: >-
          --health-cmd "curl -f http://localhost:6333/healthz || exit 1"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore NuGet cache
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json', '**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Setup environment files
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY || 'sk-or-test-key-placeholder' }}
        run: |
          cd infra/env
          cp api.env.dev.example api.env.dev
          sed -i "s|OPENROUTER_API_KEY=.*|OPENROUTER_API_KEY=${OPENROUTER_API_KEY}|" api.env.dev

      # Optimization 6: Docker Buildx with GitHub Actions cache
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Build API with cache
        uses: docker/build-push-action@v5
        with:
          context: ./apps/api
          file: ./apps/api/src/Api/Dockerfile
          push: false
          load: true
          tags: meepleai-api:latest
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new,mode=max

      # Optimization 7: Move cache to avoid growing indefinitely
      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache

      - name: Start API container
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        run: |
          docker run -d \
            --name api \
            --network host \
            -e ASPNETCORE_ENVIRONMENT=Development \
            -e ASPNETCORE_URLS=http://+:8080 \
            -e ConnectionStrings__Postgres="Host=localhost;Port=5432;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}" \
            -e REDIS_URL=localhost:6379 \
            -e QDRANT_URL=http://localhost:6333 \
            -e SEQ_URL=http://localhost:5341 \
            -e OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY || 'sk-or-test-key-placeholder' }} \
            -e CI=true \
            meepleai-api:latest

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API health check..."
          for i in {1..60}; do
            if curl -f http://localhost:8080/health/ready > /dev/null 2>&1; then
              echo "API is ready"
              break
            fi
            echo "Waiting for API... ($i/60)"
            sleep 5
          done

          # Final health check
          curl -v http://localhost:8080/health

      - name: Verify seed data
        run: |
          curl -v http://localhost:8080/api/v1/games | jq '.'

      # Save API image as artifact for load test jobs
      - name: Save API image
        run: |
          docker save meepleai-api:latest | gzip > /tmp/api-image.tar.gz

      - name: Upload API image
        uses: actions/upload-artifact@v4
        with:
          name: api-image
          path: /tmp/api-image.tar.gz
          retention-days: 1

  # Optimization 8: Load test jobs use shared infrastructure
  load-test:
    name: Run Load Tests
    runs-on: ubuntu-latest
    needs: [setup, infrastructure]
    timeout-minutes: 20

    strategy:
      matrix:
        test-file:
          - games-list-load-test.js
          - chat-load-test.js
          - qa-agent-load-test.js

    # Optimization 9: Reuse service containers from infrastructure job
    services:
      postgres:
        image: postgres:16.4-alpine3.20
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      redis:
        image: redis:7.4.1-alpine3.20
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

      qdrant:
        image: qdrant/qdrant:v1.12.4
        ports:
          - 6333:6333
          - 6334:6334
        options: >-
          --health-cmd "curl -f http://localhost:6333/healthz || exit 1"
          --health-interval 5s
          --health-timeout 3s
          --health-retries 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Optimization 10: Restore k6 from cache (instant if cached)
      - name: Restore k6 cache
        uses: actions/cache@v4
        with:
          path: /usr/bin/k6
          key: ${{ runner.os }}-k6-${{ env.K6_VERSION }}
          restore-keys: |
            ${{ runner.os }}-k6-

      - name: Verify k6 installation
        run: k6 version

      # Optimization 11: Download pre-built API image
      - name: Download API image
        uses: actions/download-artifact@v4
        with:
          name: api-image
          path: /tmp

      - name: Load API image
        run: |
          docker load < /tmp/api-image.tar.gz

      - name: Setup environment files
        env:
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY || 'sk-or-test-key-placeholder' }}
        run: |
          cd infra/env
          cp api.env.dev.example api.env.dev
          sed -i "s|OPENROUTER_API_KEY=.*|OPENROUTER_API_KEY=${OPENROUTER_API_KEY}|" api.env.dev

      - name: Start API container
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        run: |
          docker run -d \
            --name api \
            --network host \
            -e ASPNETCORE_ENVIRONMENT=Development \
            -e ASPNETCORE_URLS=http://+:8080 \
            -e ConnectionStrings__Postgres="Host=localhost;Port=5432;Database=${POSTGRES_DB};Username=${POSTGRES_USER};Password=${POSTGRES_PASSWORD}" \
            -e REDIS_URL=localhost:6379 \
            -e QDRANT_URL=http://localhost:6333 \
            -e SEQ_URL=http://localhost:5341 \
            -e OPENROUTER_API_KEY=${{ secrets.OPENROUTER_API_KEY || 'sk-or-test-key-placeholder' }} \
            -e CI=true \
            meepleai-api:latest

      - name: Wait for API to be ready
        run: |
          echo "Waiting for API health check..."
          for i in {1..30}; do
            if curl -f http://localhost:8080/health/ready > /dev/null 2>&1; then
              echo "API is ready"
              exit 0
            fi
            echo "Waiting for API... ($i/30)"
            sleep 3
          done

          echo "API failed to start"
          docker logs api
          exit 1

      - name: Run load test - ${{ matrix.test-file }}
        env:
          SCENARIO: ${{ github.event.inputs.scenario || 'users100' }}
          API_BASE_URL: http://localhost:8080
        run: |
          cd tests/load
          echo "Running ${{ matrix.test-file }} with scenario: $SCENARIO"
          k6 run --out json=${{ matrix.test-file }}.results.json \
                 --summary-export=${{ matrix.test-file }}.summary.json \
                 ${{ matrix.test-file }}

      - name: Generate HTML report
        if: always()
        run: |
          cd tests/load
          cat > ${{ matrix.test-file }}.report.html << 'EOF'
          <!DOCTYPE html>
          <html>
          <head>
            <title>Load Test Report - ${{ matrix.test-file }}</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
              .container { background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
              h1 { color: #333; border-bottom: 3px solid #4CAF50; padding-bottom: 10px; }
              h2 { color: #555; margin-top: 30px; }
              table { width: 100%; border-collapse: collapse; margin: 20px 0; }
              th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
              th { background-color: #4CAF50; color: white; }
              tr:hover { background-color: #f5f5f5; }
              .metric { font-weight: bold; color: #4CAF50; }
              .threshold-pass { color: #4CAF50; }
              .threshold-fail { color: #f44336; }
              pre { background: #f4f4f4; padding: 15px; border-radius: 4px; overflow-x: auto; }
            </style>
          </head>
          <body>
            <div class="container">
              <h1>Load Test Report: ${{ matrix.test-file }}</h1>
              <p><strong>Scenario:</strong> ${{ github.event.inputs.scenario || 'users100' }}</p>
              <p><strong>Date:</strong> $(date)</p>
              <p><strong>API Base URL:</strong> http://localhost:8080</p>
              <p><strong>Optimizations:</strong> Docker cache, NuGet cache, k6 cache, service containers</p>

              <h2>Test Results</h2>
              <p>See JSON files for detailed metrics.</p>

              <h2>Files Generated</h2>
              <ul>
                <li>Results: ${{ matrix.test-file }}.results.json</li>
                <li>Summary: ${{ matrix.test-file }}.summary.json</li>
              </ul>
            </div>
          </body>
          </html>
          EOF

      - name: Upload load test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: load-test-results-${{ matrix.test-file }}-${{ github.event.inputs.scenario || 'users100' }}
          path: |
            tests/load/*.results.json
            tests/load/*.summary.json
            tests/load/*.report.html
          retention-days: 30

      - name: Check for test failures
        if: always()
        run: |
          cd tests/load
          if [ -f "${{ matrix.test-file }}.summary.json" ]; then
            echo "Test summary:"
            cat ${{ matrix.test-file }}.summary.json | jq '.metrics'
          fi

      - name: Display service logs on failure
        if: failure()
        run: |
          echo "=== API Logs ==="
          docker logs api | tail -100

      - name: Cleanup
        if: always()
        run: |
          docker stop api || true
          docker rm api || true

  summary:
    name: Load Test Summary
    runs-on: ubuntu-latest
    needs: load-test
    if: always()

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: load-test-results

      - name: Display summary
        run: |
          echo "=== Load Test Summary ==="
          echo "All load test results have been collected."
          echo "Check the artifacts for detailed reports."
          echo ""
          echo "Optimizations applied:"
          echo "  ✅ NuGet package caching"
          echo "  ✅ Docker layer caching with Buildx"
          echo "  ✅ k6 binary caching"
          echo "  ✅ GitHub Actions service containers"
          echo "  ✅ Shared setup job"
          echo "  ✅ Pre-built API image artifact"
          echo ""
          ls -R load-test-results/
