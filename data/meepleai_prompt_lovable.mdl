# MeepleAI â€“ Prompt per Lovable.dev

## ğŸŒŸ Descrizione generale

Costruisci un'applicazione fullâ€‘stack chiamata **MeepleAI** che aiuti gli amanti dei giochi da tavolo a scoprire, imparare e giocare meglio.  
L'app deve combinare un **frontend React/Next.js** con un **backend .NET** esposto tramite API REST e supportato da **PostgreSQL** per i dati strutturati, **Redis** per la cache, **Qdrant** come vettore store per il Retrievalâ€‘Augmented Generation (RAG) e una coda **n8n** per orchestrare i flussi asincroni.  
Lâ€™intero stack gira tramite **[Docker Compose]** con healthâ€‘check su ogni servizio e variabili dâ€™ambiente separate per sviluppo locale e CI.  
Le risposte alle domande degli utenti devono essere generate con un **[AI model]** (OpenAI, Anthropic, ecc.) in modalitÃ  RAG, recuperando i paragrafi dai manuali ufficiali salvati in Qdrant; ogni risposta deve includere citazioni alla fonte originale renderizzate con **[Markdown Renderer]**.

### ğŸ® FunzionalitÃ  per gli utenti

- **Esplora giochi**: una libreria consultabile di giochi da tavolo con filtri per genere, difficoltÃ , durata, numero di giocatori e raccomandazioni basate sul profilo.  
- **Domande e risposte**: chat in tempo reale che consenta agli utenti di porre domande naturali sulle regole (es. â€œCome funziona la fase di combattimento in *Scythe*?â€) e ottenere risposte precise con riferimenti alle sezioni del manuale.  
- **Tutor di partita**: modalitÃ  attivabile durante una sessione di gioco che ricorda regole dimenticate, risponde ai dubbi del gruppo, riassume i turni e verifica le condizioni di vittoria.  
- **Profilo giocatore**: registrazione e login tramite gli endpoint `/auth/register`, `/auth/login`, `/auth/logout` e `/auth/me`.  
  Ogni utente puÃ² salvare giochi preferiti, tracciare le partite, ricevere suggerimenti personalizzati, aggiungere note personali e creare varianti delle regole condivisibili con gli amici.  
- **Caricamento manuali**: se un gioco non Ã¨ presente, un utente con ruolo **Editor** o **Admin** puÃ² caricare un **PDF** o testo del manuale tramite il wizard multiâ€‘step `/upload`.  
  Il wizard guida lâ€™utente attraverso: scelta o creazione di un gioco, upload del file (`POST /ingest/pdf`), polling dello stato di parsing (`/pdfs/{documentId}/text`), revisione della RuleSpec estratta e pubblicazione con â€œPublish RuleSpecâ€.  
- **Chat persistente**: le conversazioni sono persistenti per ogni gioco/regolamento; lâ€™app deve gestire la finestra di contesto e followâ€‘up intelligenti.  
- **Dashboard amministrativa**: per utenti **Admin** una dashboard con log filtrabili, statistiche e gestione dei flussi **n8n**, incluso un endpoint `/admin/seed` per popolazione demo.  
- **ModalitÃ  multigiocatore online** (funzionalitÃ  Pro): consente a piÃ¹ giocatori di condividere lo stesso assistente durante una partita virtuale.  
- **API pubblica**: esponi endpoint documentati per integrazioni di terze parti; supporta chiavi API per accesso controllato.  

### ğŸ§  Backend e dati

1. **Autenticazione & ruoli** â€“ implementa un sistema basato su cookie `HttpOnly` e tabelle `users`/`user_sessions` gestite da **EF Core**; i ruoli (`Admin`, `Editor`, `User`) determinano i permessi sugli endpoint.  
2. **Modello dati** â€“ utilizza un contesto unico con tabelle come `users`, `games`, `rule_specs`, `agents`, `chats`, `chat_logs` e `audit_logs`; le entitÃ  devono essere indicizzate su chiavi naturali (`user_id`, `game_id`, ecc.) senza partizionamento.  
3. **RAG e Qdrant** â€“ archivia testi dei manuali nel database vettoriale **Qdrant**.  Durante ogni richiesta di QA, effettua embedding con il modello scelto, cerca i chunk rilevanti e li passa al **[AI model]** per generare risposte con citazioni.  
4. **Caching e queue** â€“ integra **Redis** per cache distribuita e una coda per il processamento asincrono (es. parsing PDF).  
5. **Health check e configurazione** â€“ ogni microservizio deve esporre un endpoint di health check; configura CORS tramite la chiave `AllowedOrigins`; usa file `.env.dev`/`.env.ci` per i segreti.  
6. **Migrazioni EF Core** â€“ gestisci il database tramite migrations versionate; includi uno script per seed demo (`POST /admin/seed`).

### ğŸ–¥ï¸ Frontend (Next.js)

- Usa **Next.js** con TypeScript e **[Chakra UI]** o **[shadcn/ui]** per i componenti.  
- Implementa pagine principali: homepage con presentazione del servizio e link alla libreria di giochi; pagina `/games` con filtri; `/games/[id]` per dettagli e chat; `/upload` per il wizard di importazione; `/dashboard` per lâ€™area admin; `/profile` per il profilo utente; `/login` e `/register`.  
- La chat deve supportare invio di prompt, visualizzazione streaming delle risposte e citazioni cliccabili che aprono la sezione corrispondente del manuale (renderizzata via **[Markdown Renderer]**).  
- Visualizza lo stato del parsing PDF con una barra di progresso e polling automatico; disabilita il pulsante â€œContinueâ€ finchÃ© `processingStatus` non diventa `completed`.

### ğŸ”’ Sicurezza e DevOps

- Includi hook di preâ€‘commit (es. detectâ€‘secrets) e linee guida di contribuzione.  
- Gestisci segreti e chiavi API tramite variabili dâ€™ambiente e rotazione periodica (OpenRouter API, GitHub PAT, `N8N_ENCRYPTION_KEY`).  
- Automatizza la pipeline CI/CD con test unitari, integration test (TestContainers per PostgreSQL e Qdrant), linting e coverage reporting.  

### ğŸš€ Roadmap inclusa

Integra nella visione del progetto anche le funzionalitÃ  pianificate, tra cui:  
- completare la pipeline di ingestion con upload multipli, estrazione avanzata di tabelle/immagini e chunking intelligente;  
- supporto a chat multiâ€‘turno persistente con gestione del contesto e followâ€‘up;  
- UI/UX evoluta con dashboard e visualizzazione dei documenti sorgente;  
- integrazione di provider LLM multipli;  
- caching avanzato, ottimizzazione vector search, observability;  
- supporto multimodale (immagini, diagrammi, video), AI Game Master, funzioni community, mobile app, interfaccia vocale, gamification e marketplace per contenuti creati dagli utenti.  

## âœ… Output atteso

Al termine, il progetto su Lovable.dev deve generare unâ€™applicazione funzionante che replica la struttura, lâ€™interfaccia e le funzionalitÃ  descritte in `README.md` e `WELCOME.md`.  
Gli utenti possono navigare, registrarsi, esplorare giochi, porre domande, caricare manuali e utilizzare la modalitÃ  tutor.  Gli amministratori dispongono di strumenti di gestione e seed; gli sviluppatori possono estendere il sistema grazie alle API pubbliche e alla configurazione modulare via **Docker Compose**.