# MeepleAI – Prompt per Lovable.dev

## 🌟 Descrizione generale

Costruisci un'applicazione full‑stack chiamata **MeepleAI** che aiuti gli amanti dei giochi da tavolo a scoprire, imparare e giocare meglio.  
L'app deve combinare un **frontend React/Next.js** con un **backend .NET** esposto tramite API REST e supportato da **PostgreSQL** per i dati strutturati, **Redis** per la cache, **Qdrant** come vettore store per il Retrieval‑Augmented Generation (RAG) e una coda **n8n** per orchestrare i flussi asincroni.  
L’intero stack gira tramite **[Docker Compose]** con health‑check su ogni servizio e variabili d’ambiente separate per sviluppo locale e CI.  
Le risposte alle domande degli utenti devono essere generate con un **[AI model]** (OpenAI, Anthropic, ecc.) in modalità RAG, recuperando i paragrafi dai manuali ufficiali salvati in Qdrant; ogni risposta deve includere citazioni alla fonte originale renderizzate con **[Markdown Renderer]**.

### 🎮 Funzionalità per gli utenti

- **Esplora giochi**: una libreria consultabile di giochi da tavolo con filtri per genere, difficoltà, durata, numero di giocatori e raccomandazioni basate sul profilo.  
- **Domande e risposte**: chat in tempo reale che consenta agli utenti di porre domande naturali sulle regole (es. “Come funziona la fase di combattimento in *Scythe*?”) e ottenere risposte precise con riferimenti alle sezioni del manuale.  
- **Tutor di partita**: modalità attivabile durante una sessione di gioco che ricorda regole dimenticate, risponde ai dubbi del gruppo, riassume i turni e verifica le condizioni di vittoria.  
- **Profilo giocatore**: registrazione e login tramite gli endpoint `/auth/register`, `/auth/login`, `/auth/logout` e `/auth/me`.  
  Ogni utente può salvare giochi preferiti, tracciare le partite, ricevere suggerimenti personalizzati, aggiungere note personali e creare varianti delle regole condivisibili con gli amici.  
- **Caricamento manuali**: se un gioco non è presente, un utente con ruolo **Editor** o **Admin** può caricare un **PDF** o testo del manuale tramite il wizard multi‑step `/upload`.  
  Il wizard guida l’utente attraverso: scelta o creazione di un gioco, upload del file (`POST /ingest/pdf`), polling dello stato di parsing (`/pdfs/{documentId}/text`), revisione della RuleSpec estratta e pubblicazione con “Publish RuleSpec”.  
- **Chat persistente**: le conversazioni sono persistenti per ogni gioco/regolamento; l’app deve gestire la finestra di contesto e follow‑up intelligenti.  
- **Dashboard amministrativa**: per utenti **Admin** una dashboard con log filtrabili, statistiche e gestione dei flussi **n8n**, incluso un endpoint `/admin/seed` per popolazione demo.  
- **Modalità multigiocatore online** (funzionalità Pro): consente a più giocatori di condividere lo stesso assistente durante una partita virtuale.  
- **API pubblica**: esponi endpoint documentati per integrazioni di terze parti; supporta chiavi API per accesso controllato.  

### 🧠 Backend e dati

1. **Autenticazione & ruoli** – implementa un sistema basato su cookie `HttpOnly` e tabelle `users`/`user_sessions` gestite da **EF Core**; i ruoli (`Admin`, `Editor`, `User`) determinano i permessi sugli endpoint.  
2. **Modello dati** – utilizza un contesto unico con tabelle come `users`, `games`, `rule_specs`, `agents`, `chats`, `chat_logs` e `audit_logs`; le entità devono essere indicizzate su chiavi naturali (`user_id`, `game_id`, ecc.) senza partizionamento.  
3. **RAG e Qdrant** – archivia testi dei manuali nel database vettoriale **Qdrant**.  Durante ogni richiesta di QA, effettua embedding con il modello scelto, cerca i chunk rilevanti e li passa al **[AI model]** per generare risposte con citazioni.  
4. **Caching e queue** – integra **Redis** per cache distribuita e una coda per il processamento asincrono (es. parsing PDF).  
5. **Health check e configurazione** – ogni microservizio deve esporre un endpoint di health check; configura CORS tramite la chiave `AllowedOrigins`; usa file `.env.dev`/`.env.ci` per i segreti.  
6. **Migrazioni EF Core** – gestisci il database tramite migrations versionate; includi uno script per seed demo (`POST /admin/seed`).

### 🖥️ Frontend (Next.js)

- Usa **Next.js** con TypeScript e **[Chakra UI]** o **[shadcn/ui]** per i componenti.  
- Implementa pagine principali: homepage con presentazione del servizio e link alla libreria di giochi; pagina `/games` con filtri; `/games/[id]` per dettagli e chat; `/upload` per il wizard di importazione; `/dashboard` per l’area admin; `/profile` per il profilo utente; `/login` e `/register`.  
- La chat deve supportare invio di prompt, visualizzazione streaming delle risposte e citazioni cliccabili che aprono la sezione corrispondente del manuale (renderizzata via **[Markdown Renderer]**).  
- Visualizza lo stato del parsing PDF con una barra di progresso e polling automatico; disabilita il pulsante “Continue” finché `processingStatus` non diventa `completed`.

### 🔒 Sicurezza e DevOps

- Includi hook di pre‑commit (es. detect‑secrets) e linee guida di contribuzione.  
- Gestisci segreti e chiavi API tramite variabili d’ambiente e rotazione periodica (OpenRouter API, GitHub PAT, `N8N_ENCRYPTION_KEY`).  
- Automatizza la pipeline CI/CD con test unitari, integration test (TestContainers per PostgreSQL e Qdrant), linting e coverage reporting.  

### 🚀 Roadmap inclusa

Integra nella visione del progetto anche le funzionalità pianificate, tra cui:  
- completare la pipeline di ingestion con upload multipli, estrazione avanzata di tabelle/immagini e chunking intelligente;  
- supporto a chat multi‑turno persistente con gestione del contesto e follow‑up;  
- UI/UX evoluta con dashboard e visualizzazione dei documenti sorgente;  
- integrazione di provider LLM multipli;  
- caching avanzato, ottimizzazione vector search, observability;  
- supporto multimodale (immagini, diagrammi, video), AI Game Master, funzioni community, mobile app, interfaccia vocale, gamification e marketplace per contenuti creati dagli utenti.  

## ✅ Output atteso

Al termine, il progetto su Lovable.dev deve generare un’applicazione funzionante che replica la struttura, l’interfaccia e le funzionalità descritte in `README.md` e `WELCOME.md`.  
Gli utenti possono navigare, registrarsi, esplorare giochi, porre domande, caricare manuali e utilizzare la modalità tutor.  Gli amministratori dispongono di strumenti di gestione e seed; gli sviluppatori possono estendere il sistema grazie alle API pubbliche e alla configurazione modulare via **Docker Compose**.